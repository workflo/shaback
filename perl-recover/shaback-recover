#! /usr/bin/perl -w

#
# Recover an ODC-Style CPIO Archive as used by shaback recover --cpio
#

use File::Path qw(mkpath);

print "Hallo, Welt ...\n";

my ($file) = @ARGV;
my $cpio = Archive::Cpio->new;

my $numDirsRestored = 0;
my $numFilesRestored = 0;
my $numLinksRestored = 0;
my $numBytesRestored = 0;

my $IN;
if ($file) {
  open($IN, '<', $file) or die "can't open $file: $!\n";
} else {
  $IN = \*STDIN;
}
binmode($IN);
$cpio->restore_run($IN);

printf "Restored %d Bytes in %d files, %d dirs, %d links\n", $numBytesRestored, $numFilesRestored, $numDirsRestored, $numLinksRestored;
exit 0;



sub restoreMetaData($$) {
  my ($file, $entry) = @_;
  my $num;

  # TBI: Muss lchown sein
  $num = chown $entry->{uid}, $entry->{gid}, $file;
  if ($num != 1) {
    # TBI: Fehlerbehandlung
  };

  if ($entry->{type} ne 'l') {
    $num = chmod $entry->{perm}, $file;
    if ($num != 1) {
      # TBI: Fehlerbehandlung
    }
  }

  $num = utime $entry->{mtime}, $entry->{mtime}, $file;
  if ($num != 1) {
      # TBI: Fehlerbehandlung
  }

  # TBI: shaback stellt hier auch user.shaback.sha1/user.shaback.mtime wieder her
}


#########################################################################


package Archive::Cpio::Common;

sub magics() {
    {
	"070707" => 'ODC',
	"070701" => 'NewAscii',
	"\xC7\x71" => 'OldBinary', # swabbed 070707
	"\x71\xC7" => 'OldBinary', # 070707
    };
}


sub max  { my $n = shift; $_ > $n and $n = $_ foreach @_; $n }


sub begins_with {
    my ($s, $prefix) = @_;
    index($s, $prefix) == 0;
}

#########################################################################

package Archive::Cpio::ODC;

use Fcntl qw(:DEFAULT);

#use Archive::Cpio::Common;

sub HEADER() {
 (
    magic => 6,
    dev => 6,
    inode => 6,
    mode => 6,
    uid => 6,
    gid => 6,
    nlink => 6,
    rdev => 6,
    mtime => 11,
    namesize => 6,
    datasize => 11,
);
}


sub new {
    my ($class, $magic) = @_;
    bless { magic => oct($magic) }, $class;
}


sub restore_one {
    my ($o, $FHwp) = @_;
    # Meta Data
    my $entry = read_one_header($o, $FHwp);

    # File Header
    $entry->{name} = $FHwp->read($entry->{namesize});
    $entry->{name} =~ s/\0$//;
    $entry->{name} ne "TRAILER!!!" or return;

    # $entry->{magic}: Konstant
    # $entry->{dev}: Konstant
    # $entry->{inode}: Der wievielte Eintrag im Archiv
    #print "Entry: " . $entry->{inode} . " " . $entry->{name} . "\n";
    my $type = ($entry->{mode} & 0770000);
    $entry->{perm} = ($entry->{mode} & 0007777);

    if ($type == 0040000) { # Dir
      $entry->{type} = 'd';
      printf "d: %s (%d)\n", $entry->{name}, $entry->{inode};
      my $data = $FHwp->read($entry->{datasize}); # empty
      ::mkpath($entry->{name});
      ::restoreMetaData($entry->{name}, $entry);
      $numDirsRestored++;

    } elsif ($type == 0100000) { # File
      $entry->{type} = 'f';
      printf "f: (%d B) %s (%d)\n", $entry->{datasize}, $entry->{name}, $entry->{inode};
      unlink $entry->{name}; # in case the target exists as a link
      my $out;
      sysopen($out, $entry->{name}, O_WRONLY | O_CREAT | O_LARGEFILE) || die "$entry->{name}: $!";
      binmode $out;
      $FHwp->copy_to($out, $entry->{datasize});

      ::restoreMetaData($entry->{name}, $entry);
      $numFilesRestored++;
      $numBytesRestored += $entry->{datasize};

    } elsif ($type == 0120000) { # Symlink
      $entry->{type} = 'l';
      printf "l: %s (%d)\n", $entry->{name}, $entry->{inode};
      my $oldfile = $FHwp->read($entry->{datasize});

      unlink $entry->{name}; # Symlink would not work, otherwise
      if (symlink $oldfile, $entry->{name}) {
        # TBI: Fehlerbehandlung
      }
      ::restoreMetaData($entry->{name}, $entry);
      $numLinksRestored++;

    } else {
      printf "E: Unsupported type %06o, skipping: %s", $type, $entry->{name};
      $FHwp->read($entry->{datasize});
      #<Flo> #define __S_IFDIR 0040000 /* Directory.  */
      #<Flo> #define __S_IFCHR 0020000 /* Character device.  */
      #<Flo> #define __S_IFBLK 0060000 /* Block device.  */
      #<Flo> #define __S_IFREG 0100000 /* Regular file.  */
      #<Flo> #define __S_IFIFO 0010000 /* FIFO.  */
      #<Flo> #define __S_IFLNK 0120000 /* Symbolic link.  */
      #<Flo> #define __S_IFSOCK 0140000 /* Socket.  */
    }

    # Just for output
    cleanup_entry($entry);
    return $entry;
}


sub read_one_header {
    my ($o, $FHwp) = @_;

    my %h;
    my @header = HEADER();

    while (@header) {
	my $field = shift @header;
	my $size =  shift @header;
	$h{$field} = $FHwp->read($size);
	$h{$field} =~ /^[0-9]*$/si or die "bad header value $h{$field}\n";
	$h{$field} = oct $h{$field};
    }
    my $l = $h{magic};
    my $r = $o->{magic};
    ($l == $r) or die "bad magic ($l vs $r)\n";

    \%h;
}


sub cleanup_entry {
    my ($entry) = @_;

    foreach ('datasize', 'namesize', 'magic') {
	delete $entry->{$_};
    }
}


#########################################################################

package Archive::Cpio::FileHandle_with_pushback;

sub new {
    my ($class, $F) = @_;
    bless { F => $F, already_read => '' }, $class;
}


sub pushback {
    my ($FHwp, $s) = @_;

    $FHwp->{already_read} .= $s;
}


sub read {
    my ($FHwp, $size) = @_;

    $size or return;

    $size =~ /^\d+$/ or die "bad size $size\n";

    my $tmp = '';

    if ($FHwp->{already_read}) {
	$tmp = substr($FHwp->{already_read}, 0, $size);
	substr($FHwp->{already_read}, 0, $size) = '';
	$size -= length($tmp);
        return $tmp if ($size == 0);
    }

    read($FHwp->{F}, $tmp, $size, length($tmp)) == $size or die "unexpected end of file while reading (got $tmp)\n";
    return $tmp;
}


sub read_ahead {
    my ($FHwp, $size) = @_;

    my $s = $FHwp->read($size);
    $FHwp->pushback($s);
    $s;
}

#
# $len bytes lesen und nach $out schreiben
sub copy_to {
  my ($FHwp, $out, $len) = @_;

  # Read-ahead aufloesen, FIXME: Ich glaube, hier kommt man gar nicht hin
  if ($FHwp->{already_read}) {
    syswrite $out, $FHwp->{already_read}|| die;
    $len -= length($FHwp->{already_read});
    $FHwp->{already_read} = '';
  }

  # Blockweise schreiben
  my $buf;
  my $bs = 8192; # TBI: Optimale (?) Block-groesse

  while ($len > 0) {
    my $cs = $len < $bs ? $len : $bs; # chunk suze
    CORE::read($FHwp->{F}, $buf, $cs) == $cs or die "unexpected end of file while reading (got $buf)\n";
    syswrite $out, $buf;
    $len -= $cs;
  }
}

#########################################################################


package Archive::Cpio::File;

sub new {
    my ($class, $val) = @_;

    bless $val, $class;
}

sub name { my ($o) = @_; $o->{name} }
sub size { my ($o) = @_; length($o->{data}) }
sub get_content { my ($o) = @_; $o->{data} }



#########################################################################


package Archive::Cpio;

our $VERSION = 0.09;

sub new {
    my ($class, %options) = @_;
    bless \%options, $class;
}


sub restore_run {
    my ($cpio, $F, $handler) = @_;

    my $FHwp = Archive::Cpio::FileHandle_with_pushback->new($F);
    $cpio->{archive_format} ||= detect_archive_format($FHwp);

    while (my $entry = $cpio->{archive_format}->restore_one($FHwp)) {
        #print "Done: " . $entry->{name} . "\n";
    }
}


sub detect_archive_format {
    my ($FHwp) = @_;

    my $magics = Archive::Cpio::Common::magics();

    my $max_length = Archive::Cpio::Common::max(map { length $_ } values %$magics);
    my $s = $FHwp->read_ahead($max_length);

    foreach my $magic (keys %$magics) {
	my $archive_format = $magics->{$magic};
	Archive::Cpio::Common::begins_with($s, $magic) or next;
	
	#warn "found magic for $archive_format\n";

	# my $class = "Archive::Cpio::$archive_format";
	return Archive::Cpio::ODC->new($magic, $s);
    }
    die "invalid archive\n";
}
